import { useEffect, useState, useRef } from 'react';
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Placeholder from '@tiptap/extension-placeholder';
import { HighlightMark } from '../extensions/highlight';
import { useStore } from '../store/useStore';
import { SelectionToolbar } from './SelectionToolbar';
import { DiffSuggestion } from './DiffSuggestion';
import { openRouterService } from '../services/openrouter';
import { computeDiff, applyDiff } from '../services/diffService';
import type { AISuggestion } from '../types';
import './Editor.css';

export const Editor = () => {
  const {
    content,
    setContent,
    characters,
    aiSuggestions,
    addAISuggestion,
    removeAISuggestion,
    clearAISuggestions,
    clearComments, // è”åŠ¨ï¼šå½“æ¥å—å»ºè®®ä¿®æ”¹å†…å®¹åï¼Œæ¸…ç©ºå³ä¾§è¯„è®º
  } = useStore();

  const [showToolbar, setShowToolbar] = useState(false);
  const [selectedText, setSelectedText] = useState('');
  const [selectedRange, setSelectedRange] = useState<{ from: number; to: number } | null>(null);
  const [toolbarPosition, setToolbarPosition] = useState({ x: 0, y: 0 });
  const [isGeneratingSuggestion, setIsGeneratingSuggestion] = useState(false);
  const [suggestionPosition, setSuggestionPosition] = useState<{ top: number; left: number } | null>(null);

  const editorRef = useRef<HTMLDivElement>(null);

  const editor = useEditor({
    extensions: [
      StarterKit,
      Placeholder.configure({
        placeholder: 'å¼€å§‹å†™ç‚¹ä»€ä¹ˆå§... ğŸ’­',
      }),
      HighlightMark,
    ],
    content,
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl focus:outline-none',
      },
    },
    onUpdate: ({ editor }) => {
      const html = editor.getHTML();
      setContent(html);
    },
    onSelectionUpdate: ({ editor }) => {
      const { from, to } = editor.state.selection;

      // æ¸…é™¤ä¹‹å‰çš„å»ºè®®
      if (aiSuggestions.length > 0) {
        clearAISuggestions();
      }

      if (from !== to) {
        const text = editor.state.doc.textBetween(from, to, ' ');
        if (text.length > 10) {
          setSelectedText(text);
          setSelectedRange({ from, to });

          // è®¡ç®—å·¥å…·æ ä½ç½®
          setTimeout(() => {
            try {
              const selection = window.getSelection();
              if (selection && selection.rangeCount > 0) {
                const domRange = selection.getRangeAt(0);
                const rect = domRange.getBoundingClientRect();
                const editorWrapper = editorRef.current;

                if (editorWrapper) {
                  const editorRect = editorWrapper.getBoundingClientRect();
                  setToolbarPosition({
                    x: rect.left + rect.width / 2 - editorRect.left,
                    y: rect.top - editorRect.top,
                  });
                  setShowToolbar(true);
                }
              }
            } catch (error) {
              console.error('è·å–é€‰åŒºä½ç½®å¤±è´¥:', error);
              setShowToolbar(false);
            }
          }, 0);
        } else {
          setShowToolbar(false);
        }
      } else {
        setShowToolbar(false);
        setSelectedText('');
        setSelectedRange(null);
      }
    },
  });

  useEffect(() => {
    if (editor && content !== editor.getHTML()) {
      editor.commands.setContent(content);
    }
  }, [content, editor]);

  const handleGetSuggestion = async () => {
    if (!selectedText || !selectedRange || !editor) {
      return;
    }

    if (!openRouterService.hasApiKey()) {
      alert('è¯·å…ˆé…ç½® API Key');
      return;
    }

    setShowToolbar(false);
    setIsGeneratingSuggestion(true);

    // é«˜äº®é€‰ä¸­çš„æ–‡æœ¬ï¼Œè¡¨ç¤ºæ­£åœ¨å¤„ç†
    editor.chain()
      .focus()
      .setTextSelection(selectedRange)
      .setHighlight('#fff3cd')
      .run();

    try {
      // æå–å…¨æ–‡ä½œä¸ºä¸Šä¸‹æ–‡
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const plainText = tempDiv.textContent || tempDiv.innerText || '';

      // è·å–AIæ”¹å†™å»ºè®®
      const improvedText = await openRouterService.getRewriteSuggestion(selectedText, plainText);

      // è®¡ç®—diff
      const diff = computeDiff(selectedText, improvedText);

      // åˆ›å»ºå»ºè®®
      const suggestion: AISuggestion = {
        id: `suggestion-${Date.now()}`,
        characterId: 'jiucuo',
        originalText: selectedText,
        improvedText,
        diff,
        comment: 'å·²ä¸ºæ‚¨ä¼˜åŒ–é€‰ä¸­çš„æ–‡æœ¬ï¼Œè¯·æŸ¥çœ‹å»ºè®®ä¿®æ”¹ã€‚',
        position: selectedRange,
        timestamp: Date.now(),
      };

      addAISuggestion(suggestion);

      // è®¡ç®—å»ºè®®å¡ç‰‡çš„ä½ç½®ï¼ˆåœ¨é«˜äº®æ–‡æœ¬ä¸‹æ–¹ï¼‰
      setTimeout(() => {
        try {
          const editorWrapper = editorRef.current;
          if (!editorWrapper) return;

          // æŸ¥æ‰¾é«˜äº®çš„markå…ƒç´ 
          const markElements = editorWrapper.querySelectorAll('mark');
          if (markElements.length > 0) {
            const lastMark = markElements[markElements.length - 1];
            const rect = lastMark.getBoundingClientRect();
            const editorRect = editorWrapper.getBoundingClientRect();

            setSuggestionPosition({
              top: rect.bottom - editorRect.top + 10,
              left: rect.left - editorRect.left,
            });
          } else {
            // å¦‚æœæ‰¾ä¸åˆ°markå…ƒç´ ï¼Œä½¿ç”¨é»˜è®¤ä½ç½®
            setSuggestionPosition({ top: 200, left: 50 });
          }
        } catch (error) {
          console.error('è®¡ç®—å»ºè®®ä½ç½®å¤±è´¥:', error);
          setSuggestionPosition({ top: 200, left: 50 });
        }
      }, 100);
    } catch (error) {
      alert(error instanceof Error ? error.message : 'ç”Ÿæˆå»ºè®®å¤±è´¥');
      // å‡ºé”™æ—¶ç§»é™¤é«˜äº®
      editor.chain()
        .focus()
        .setTextSelection(selectedRange)
        .unsetHighlight()
        .run();
    } finally {
      setIsGeneratingSuggestion(false);
    }
  };

  const handleAcceptSuggestion = (suggestionId: string) => {
    const suggestion = aiSuggestions.find((s) => s.id === suggestionId);
    if (!suggestion || !editor) return;

    // åº”ç”¨å»ºè®®åˆ°ç¼–è¾‘å™¨
    const improvedText = applyDiff(suggestion.diff);

    editor.chain()
      .focus()
      .setTextSelection(suggestion.position)
      .unsetHighlight() // å…ˆç§»é™¤é«˜äº®
      .deleteSelection() // åˆ é™¤é€‰ä¸­å†…å®¹
      .insertContent(improvedText) // æ’å…¥æ–°å†…å®¹
      .run();

    // ç§»é™¤å»ºè®®
    removeAISuggestion(suggestionId);
    setSuggestionPosition(null);
  };

  const handleRejectSuggestion = (suggestionId: string) => {
    const suggestion = aiSuggestions.find((s) => s.id === suggestionId);
    if (!suggestion || !editor) return;

    // ç§»é™¤é«˜äº®
    editor.chain()
      .focus()
      .setTextSelection(suggestion.position)
      .unsetHighlight()
      .run();

    // ç§»é™¤å»ºè®®
    removeAISuggestion(suggestionId);
    setSuggestionPosition(null);
  };

  const getCharacter = (characterId: string) => {
    return characters.find((c) => c.id === characterId);
  };

  return (
    <div className="editor-wrapper" style={{ position: 'relative' }} ref={editorRef}>
      <EditorContent editor={editor} />

      {showToolbar && selectedText && !isGeneratingSuggestion && (
        <SelectionToolbar
          position={toolbarPosition}
          editor={editor}
          onGetSuggestion={handleGetSuggestion}
        />
      )}

      {isGeneratingSuggestion && (
        <div
          className="generating-hint"
          style={{
            position: 'absolute',
            top: `${toolbarPosition.y - 40}px`,
            left: `${toolbarPosition.x}px`,
            transform: 'translateX(-50%)',
            background: 'white',
            padding: '0.5rem 1rem',
            borderRadius: '6px',
            boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
            zIndex: 100,
            animation: 'pulse 1.5s ease-in-out infinite',
          }}
        >
          âœ¨ AIæ€è€ƒä¸­...
        </div>
      )}

      {aiSuggestions.map((suggestion) => {
        const character = getCharacter(suggestion.characterId);
        if (!character || !suggestionPosition) return null;

        return (
          <DiffSuggestion
            key={suggestion.id}
            suggestion={suggestion}
            character={character}
            position={suggestionPosition}
            onAccept={() => handleAcceptSuggestion(suggestion.id)}
            onReject={() => handleRejectSuggestion(suggestion.id)}
          />
        );
      })}
    </div>
  );
};
