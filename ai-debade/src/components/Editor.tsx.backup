import { useEffect, useState } from 'react';
import { useEditor, EditorContent } from '@tiptap/react';
import StarterKit from '@tiptap/starter-kit';
import Placeholder from '@tiptap/extension-placeholder';
import { useStore } from '../store/useStore';
import { SelectionToolbar } from './SelectionToolbar';
import { InlineComment } from './InlineComment';
import { DiffSuggestion } from './DiffSuggestion';
import { openRouterService } from '../services/openrouter';
import { computeDiff, applyDiff } from '../services/diffService';
import type { AISuggestion } from '../types';
import './Editor.css';

export const Editor = () => {
  const {
    content,
    setContent,
    setSelectedTextRange,
    comments,
    characters,
    aiSuggestions,
    addAISuggestion,
    removeAISuggestion,
  } = useStore();
  const [showToolbar, setShowToolbar] = useState(false);
  const [selectedText, setSelectedText] = useState('');
  const [selectedRange, setSelectedRange] = useState<{ from: number; to: number } | null>(null);
  const [toolbarPosition, setToolbarPosition] = useState({ x: 0, y: 0 });
  const [inlineComments, setInlineComments] = useState<Array<{ id: string; position: { top: number; left: number } }>>([]);
  const [isGeneratingSuggestion, setIsGeneratingSuggestion] = useState(false);

  const editor = useEditor({
    extensions: [
      StarterKit,
      Placeholder.configure({
        placeholder: 'ÂºÄÂßãÂÜôÁÇπ‰ªÄ‰πàÂêß... üí≠',
      }),
    ],
    content,
    editorProps: {
      attributes: {
        class: 'prose prose-sm sm:prose lg:prose-lg xl:prose-2xl focus:outline-none',
      },
    },
    onUpdate: ({ editor }) => {
      const html = editor.getHTML();
      setContent(html);
    },
    onSelectionUpdate: ({ editor }) => {
      const { from, to } = editor.state.selection;
      if (from !== to) {
        setSelectedTextRange({ from, to });
        setSelectedRange({ from, to });
        const text = editor.state.doc.textBetween(from, to, ' ');
        if (text.length > 10) {
          setSelectedText(text);

          // Ëé∑ÂèñÈÄâ‰∏≠ÊñáÊú¨ÁöÑ‰ΩçÁΩÆ - ‰øÆÂ§çÁôΩÂ±èÈóÆÈ¢ò
          setTimeout(() => {
            try {
              const selection = window.getSelection();
              if (selection && selection.rangeCount > 0) {
                const domRange = selection.getRangeAt(0);
                const rect = domRange.getBoundingClientRect();
                const editorWrapper = document.querySelector('.editor-wrapper');
                if (editorWrapper) {
                  const editorRect = editorWrapper.getBoundingClientRect();
                  setToolbarPosition({
                    x: rect.left + rect.width / 2 - editorRect.left,
                    y: rect.top - editorRect.top,
                  });
                  setShowToolbar(true);
                }
              }
            } catch (error) {
              console.error('Ëé∑ÂèñÈÄâÂå∫‰ΩçÁΩÆÂ§±Ë¥•:', error);
              setShowToolbar(false);
            }
          }, 0);
        } else {
          setShowToolbar(false);
        }
      } else {
        setSelectedTextRange(null);
        setSelectedRange(null);
        setShowToolbar(false);
      }
    },
  });

  useEffect(() => {
    if (editor && content !== editor.getHTML()) {
      editor.commands.setContent(content);
    }
  }, [content, editor]);

  // ÁõëÂê¨ËØÑËÆ∫ÁîüÊàêÂÆåÊàêÔºåÊòæÁ§∫ÂÜÖËÅîËØÑËÆ∫
  useEffect(() => {
    if (comments.length > 0) {
      const editorWrapper = document.querySelector('.editor-wrapper');
      if (!editorWrapper) return;

      const editorRect = editorWrapper.getBoundingClientRect();
      const newInlineComments = comments
        .filter(c => c.type === 'selection')
        .map(comment => {
          // ÁÆÄÂçïÂú∞Â∞ÜËØÑËÆ∫ÊòæÁ§∫Âú®ÁºñËæëÂô®‰∏≠Èó¥ÂÅè‰∏ãÁöÑ‰ΩçÁΩÆ
          return {
            id: comment.id,
            position: {
              top: 200,
              left: 50,
            },
          };
        });

      setInlineComments(newInlineComments);
    } else {
      setInlineComments([]);
    }
  }, [comments]);

  const handleGetSuggestion = async () => {
    if (!selectedText || !selectedRange || !editor) {
      return;
    }

    if (!openRouterService.hasApiKey()) {
      alert('ËØ∑ÂÖàÈÖçÁΩÆ API Key');
      return;
    }

    setShowToolbar(false);
    setIsGeneratingSuggestion(true);

    try {
      // ÊèêÂèñÂÖ®Êñá‰Ωú‰∏∫‰∏ä‰∏ãÊñá
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = content;
      const plainText = tempDiv.textContent || tempDiv.innerText || '';

      // Ëé∑ÂèñAIÊîπÂÜôÂª∫ËÆÆ
      const improvedText = await openRouterService.getRewriteSuggestion(selectedText, plainText);

      // ËÆ°ÁÆódiff
      const diff = computeDiff(selectedText, improvedText);

      // ÂàõÂª∫Âª∫ËÆÆ
      const suggestion: AISuggestion = {
        id: `suggestion-${Date.now()}`,
        characterId: 'jiucuo', // ‰ΩøÁî®Á∫†ÈîôÂ∞èÂä©Êâã
        originalText: selectedText,
        improvedText,
        diff,
        comment: 'Â∑≤‰∏∫ÊÇ®‰ºòÂåñÈÄâ‰∏≠ÁöÑÊñáÊú¨ÔºåËØ∑Êü•ÁúãÂª∫ËÆÆ‰øÆÊîπ„ÄÇ',
        position: selectedRange,
        timestamp: Date.now(),
      };

      addAISuggestion(suggestion);
    } catch (error) {
      alert(error instanceof Error ? error.message : 'ÁîüÊàêÂª∫ËÆÆÂ§±Ë¥•');
    } finally {
      setIsGeneratingSuggestion(false);
    }
  };

  const handleCloseInlineComment = (id: string) => {
    setInlineComments(prev => prev.filter(c => c.id !== id));
  };

  const handleAcceptSuggestion = (suggestionId: string) => {
    const suggestion = aiSuggestions.find(s => s.id === suggestionId);
    if (!suggestion || !editor) return;

    // Â∫îÁî®Âª∫ËÆÆÂà∞ÁºñËæëÂô®
    const improvedText = applyDiff(suggestion.diff);
    editor.chain()
      .focus()
      .deleteRange({ from: suggestion.position.from, to: suggestion.position.to })
      .insertContentAt(suggestion.position.from, improvedText)
      .run();

    // ÁßªÈô§Âª∫ËÆÆ
    removeAISuggestion(suggestionId);
  };

  const handleRejectSuggestion = (suggestionId: string) => {
    removeAISuggestion(suggestionId);
  };

  const getCharacter = (characterId: string) => {
    return characters.find((c) => c.id === characterId);
  };

  return (
    <div className="editor-wrapper" style={{ position: 'relative' }}>
      <EditorContent editor={editor} />

      {showToolbar && selectedText && !isGeneratingSuggestion && (
        <SelectionToolbar
          position={toolbarPosition}
          editor={editor}
          onGetSuggestion={handleGetSuggestion}
        />
      )}

      {isGeneratingSuggestion && (
        <div className="generating-hint" style={{
          position: 'absolute',
          top: `${toolbarPosition.y}px`,
          left: `${toolbarPosition.x}px`,
          transform: 'translate(-50%, -100%)',
          background: 'white',
          padding: '0.5rem 1rem',
          borderRadius: '6px',
          boxShadow: '0 4px 12px rgba(0,0,0,0.1)',
          zIndex: 100,
        }}>
          ‚ú® AIÊÄùËÄÉ‰∏≠...
        </div>
      )}

      {aiSuggestions.map((suggestion) => {
        const character = getCharacter(suggestion.characterId);
        if (!character) return null;

        return (
          <DiffSuggestion
            key={suggestion.id}
            suggestion={suggestion}
            character={character}
            position={{ top: 200, left: 50 }}
            onAccept={() => handleAcceptSuggestion(suggestion.id)}
            onReject={() => handleRejectSuggestion(suggestion.id)}
          />
        );
      })}

      {inlineComments.map(({ id, position }) => {
        const comment = comments.find(c => c.id === id);
        const character = comment ? getCharacter(comment.characterId) : null;
        if (!comment || !character) return null;

        return (
          <InlineComment
            key={id}
            comment={comment}
            character={character}
            position={position}
            onClose={() => handleCloseInlineComment(id)}
          />
        );
      })}
    </div>
  );
};
